Задание 11.

Правила выполнения Задания

Задание 11 - большое, и рассчитано не на один день Вашей работы. При выполнении его нужно соблюдать следующие правила :

1.	Для того, чтобы не потерять результаты своей работы, рекомендуется делать промежуточные коммиты на сервер (git push)
    по мере выполнения той или иной части. Как минимум, рекомендуется делать коммиты по окончании каждого рабочего дня.
2.	Не разрешается делать коммиты, в которых код не компилируется или не работают все тесты. Если Вы не успеваете в этот
    день исправить все ошибки - просто закомментируйте тот код, который не компилируется или не работает. Для тестов можно
    использовать аннотацию @Ignore (помещается перед аннотацией @Test), при ее наличии тест не будет запускаться.
3.	Преподаватели не будут просматривать коммиты после каждой посылки на сервер. Если Вы хотите, чтобы преподаватель
    просмотрел состояние Вашей работы и сделал свои замечания - напишите ему об этом в Скайпе или по email после того,
    как сделали коммит и дождитесь его ответа, прежде чем вносить изменения на сервере.
4.	Обсуждать Задание 11 разрешается только со своим преподавателем. Обсуждать Задание 11 (и даже упоминать о том, что Вы
    приступили к нему) в основном чате Школы, в группе Вконтакте и с другими студентами не разрешается!


	В этом задании Вам все предстоит сделать самим - разработать набор классов, написать код и тесты к нему.
Внимательно прочтите техническое задание

	Все классы предыдущих заданий можно удалить или, как минимум, удалить все тесты.
	Создайте пакет net.thumbtack.school.concert в каталогах main и test. В каталоге main в этом пакете размещайте Ваши классы,
а в каталоге test - тесты для них.
    Вы можете создавать в пакете net.thumbtack.school.concert любые  подпакеты любой степени вложенности и классы в них.
    Более того, настоятельно рекомендуется создавать такие подпакеты, а не хранить все классы в основном пакете. Имена
классов тестов должны начинаться с “Test”.

	Создайте в пакете net.thumbtack.school.concert подпакет server. Разместите в этом пакете класс Server. В этом классе
должны быть методы

1.	public void startServer(String savedDataFileName)

    Производит всю необходимую инициализацию и запускает сервер.

    savedDataFileName - имя файла, в котором было сохранено состояние сервера.  Если savedDataFileName == null, восстановление
состояния не производится, сервер стартует “с нуля”.

2.	public void stopServer(String savedDataFileName)

	Останавливает сервер и записывает все его содержимое в файл сохранения с именем savedDataFileName. Если
savedDataFileName == null, запись содержимого не производится.

    После того, как сервер запущен (выполнен метод startServer), ему можно посылать команды. Команда представляет собой
вызов одного из методов класса Server. Команды выполняются последовательно, до тех пор пока не будет вызван метод stopServer,
по выполнении которого работа сервера заканчивается.

    Все методы должны иметь одну и ту же сигнатуру.

    public String <имя-метода>(String requestJsonString)

    Все данные для запроса должны быть упакованы в json-строку и в таком виде переданы методу. Метод возвращает json-строку
с результатом выполнения операции.

    При регистрации (метод registerUser) радиослушателя возвращаемая строка (при успешном выполнении) должна обязательно
содержать поле “token” - уникальный номер, присвоенный этому радиослушателю в результате регистрации.
   Токен - некоторая текстовая строка, к которой предъявляется следующее требование : при каждом получении токена должна
выдаваться строка, отличная от всех предыдущих. Иными словами, все токены должны быть различными. Для генерации таких
строк рекомендуется использовать класс UUID (https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html). Этот класс
позволяет при каждом вызове метода randomUUID получать уникальное во всем мире значение, которое можно преобразовать в
строку с помощью метода toString.
    Это токен является “визитной карточкой” радиослушателя. Все остальные команды, выполняемые от имени этого радиослушателя,
должны содержать поле “token” во входной json-строке - параметре метода, тем самым указывая, от чьего имени выполняется
команда. Логин и пароль в этих командах задавать не надо.
    Если радиослушатель выполняет операцию выхода (метод logout) с сервера, его токен впредь считается недействительным
(невалидным). При попытке выполнить любой метод с предъявлением этого токена должен возвращаться json с ошибкой. Если
радиослушатель, вышедший с сервера, входит на него снова (метод login), он получает новый токен, который может использовать
во всех операциях вплоть до нового выхода.

    В случае успешного выполнения возвращаемая строка содержит (в формате json) требуемые по условиям команды возвращаемые данные.

    Если команда содержит неверные данные (например, при регистрации не указан логин или пароль) или не может быть выполнена
по какой-то иной причине (например, пользователь с таким логином уже зарегистрирован), метод сервера должен возвращать
json, содержащий поле “error”, описывающее характер ошибки в виде, понятном для человека (например, “Этот логин уже
используется” или “Логин abcdef уже используется”). Разрешается добавить в этот json иные поля, если разработчик считает
это необходимым.
    Вы должны самостоятельно сформулировать требования к входным данным параметров команд в том случае, когда это имеет смысл.
Например, естественным будет требование, чтобы в качестве логина и пароля не использовалась пустая строка, и, более того,
строка длины, меньше минимально допустимой. Для пароля можно сформулировать и более жесткие требования, например, потребовать
наличия хотя бы одного спецсимвола. Не должно быть двух пользователей с одним и тем же логином и т.д.

    Примеры команд

    public String registerUser(String requestJsonString)

    Регистрирует радиослушателя на сервере. requestJsonString содержит данные о радиослушателе, необходимые для регистрации.
Метод при успешном выполнении возвращает json с единственным элементом “token”. Если же команду по какой-то причине
выполнить нельзя, возвращает json с элементом “error”

    public String addSong(String requestJsonString)

    Радиослушатель добавляет новую песню на сервер. requestJsonString содержит описание песни и token, полученный как
результат выполнения команды регистрации радиослушателя. Метод при успешном выполнении возвращает пустой json.
Если же команду почему-то выполнить нельзя, возвращает json с элементом “error”

    public String getSongs(String requestJsonString)

    Радиослушатель  получает список песен. requestJsonString содержит параметры для отбора песен и token, полученный как
результат выполнения команды регистрации радиослушателя. Метод при успешном выполнении возвращает json с описанием всех
песен. Если же команду почему-то выполнить нельзя, возвращает json с элементом “error”


    Покрытие тестами

	Разрабатывая те или иные методы классов, не забывайте писать для них тесты. В наборе тестов должны быть такие, которые
проверяют правильность выполнения команд при корректных и  некорректных входных данных. Например, должны быть тесты для
регистрации радиослушателя с корректными данными, с недопустимым логином и/или паролем, с уже существующим в системе
логином, или, например, тесты, проверяющие попытку доступа с несуществующим токеном и т.д. Для оценки, насколько код
покрыт тестами, используйте Coverage.

	Все задание должно быть оформлено в виде набора тестов, вызывающих методы класса Server. Например:

@Test
public void testRegisterUser {
	Server server = new Server();
	server.startServer(null);
	String jsonRequest = “json-для-регистрации-радиослушателя”;
	String jsonResponse  = server.registerUser(jsonRequest);
	// assert’ы для jsonResponse
	server.stopServer(null);
}

Не обязательно писать все тесты в одном классе тестов, более того, настоятельно рекомендуется иметь несколько классов тестов
в соответствии с их назначением.

3d party библиотеки

	При разработке разрешается использовать библиотеки, не входящие в стандартную библиотеку Java. Подключать такие библиотеки
следует через pom.xml. В частности, рекомендуется ознакомиться с библиотекой Apache Common Collections
(https://commons.apache.org/proper/commons-collections/) и использовать ее классы.